import twilio from 'twilio';
import { EventEmitter } from 'events';
import { logOut, logError } from '../utils/logger.js';
import VoiceResponse from 'twilio/lib/twiml/VoiceResponse.js';

/**
 * Interface for status callback object
 */
interface StatusCallback {
    CallSid: string;
    [key: string]: any;
}

/**
 * Service class for handling Twilio-related operations including making calls, sending SMS and generating TwiML for the Conversation Relay service.
 * 
 * @class
 * @property {string} accountSid - Twilio account SID from environment variables
 * @property {string} authToken - Twilio authentication token from environment variables
 * @property {string} fromNumber - Twilio phone number to use as the sender
 * @property {twilio.Twilio} twilioClient - Initialized Twilio client instance
 */
class TwilioService extends EventEmitter {
    private accountSid: string;
    private authToken: string;
    private fromNumber: string;
    private twilioClient: twilio.Twilio;

    constructor() {
        super();
        this.accountSid = process.env.ACCOUNT_SID || '';
        this.authToken = process.env.AUTH_TOKEN || '';
        this.fromNumber = process.env.FROM_NUMBER || '';
        this.twilioClient = twilio(process.env.ACCOUNT_SID || '', process.env.AUTH_TOKEN || '');
        // this.twilioClient = twilio(process.env.API_KEY, process.env.API_SECRET, { process.env.ACCOUNT_SID });    // Some issue here with the API key and secret
    }

    /**
     * Makes an outbound call and connects it to the Conversation Relay service.
     * The call is automatically recorded and uses TwiML generated by connectConversationRelay.
     * 
     * @param {string} toNumber - The destination phone number in E.164 format
     * @param {string} callReference - Unique reference ID for the customer
     * @param {string} serverBaseUrl - Base URL for the Conversation Relay WebSocket server (without wss:// prefix)
     * @returns {Promise<any>} The Twilio call object if successful
     * @throws {Error} If the call cannot be initiated or other Twilio API errors occur
     */
    async makeOutboundCall(serverBaseUrl: string, toNumber: string, callReference: string = ""): Promise<any> {
        try {
            const conversationRelay = this.connectConversationRelay(serverBaseUrl, callReference);

            if (!conversationRelay) {
                throw new Error('Failed to generate TwiML for conversation relay');
            }

            const call = await this.twilioClient.calls.create({
                to: toNumber,
                from: this.fromNumber,
                twiml: conversationRelay.toString(),
                // record: true,
            });

            logOut('TwilioService', `Made a call from: ${this.fromNumber} to: ${toNumber}`);
            return call;

        } catch (error) {
            logError('TwilioService', `Make Outbound call error: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    /**
     * Sends an SMS message using the configured Twilio number.
     * 
     * @param {string} to - The destination phone number in E.164 format
     * @param {string} message - The message content to send
     * @returns {Promise<string|null>} The Twilio message SID if successful, null if sending fails
     */
    async sendSMS(to: string, message: string): Promise<string | null> {
        try {
            logOut('TwilioService', `Sending SMS to: ${to} with message: ${message}`);

            const response = await this.twilioClient.messages.create({
                body: message,
                from: this.fromNumber,
                to: to
            });
            return response.sid;
        } catch (error) {
            logError('TwilioService', `Error sending SMS: ${error instanceof Error ? error.message : String(error)}`);
            return null;
        }
    }

    /**
     * Generates TwiML to connect a call to the Conversation Relay service.
     * Configures the connection with Deepgram transcription, text-to-speech settings,
     * and DTMF detection. Can be used for both inbound and outbound calls.
     * 
     * @param {string} callReference - Unique reference ID for the customer
     * @param {string} serverBaseUrl - Base URL for the Conversation Relay WebSocket server (without wss:// prefix)
     * @returns {twilio.twiml.VoiceResponse|null} The TwiML response object if successful, null if generation fails
     */
    connectConversationRelay(serverBaseUrl: string, callReference: string = ""): twilio.twiml.VoiceResponse | null {
        try {
            logOut('TwilioService', `Generating TwiML for call with callReference: ${callReference}`);

            // Generate the Twiml we will need once the call is connected. Note, this could be done in two steps via the server, were we set a url: instead of twiml:, but this just seemed overly complicated.
            const response: VoiceResponse = new twilio.twiml.VoiceResponse();
            const connect: VoiceResponse.Connect = response.connect();
            const conversationRelay: VoiceResponse.ConversationRelay = connect.conversationRelay({
                url: `wss://${serverBaseUrl}/conversation-relay`,
                welcomeGreeting: "Hi! How can I help you today?",
                transcriptionProvider: "Deepgram",
                speechModel: "nova-3-general",
                hints: "",  // List of hint words for the STT engine
                interruptible: "any",
                ttsProvider: "Elevenlabs",
                voice: "Charlie-flash_v2_5",
                dtmfDetection: true, // DTMF & Speech interruptible
            } as any);

            conversationRelay.parameter(
                {
                    name: 'callReference',
                    value: callReference
                });

            // logOut('TwilioService', `Generated TwiML using Helper for call: ${response.toString()}`);

            return response;

        } catch (error) {
            logError('TwilioService', `Error generating call TwiML: ${error instanceof Error ? error.message : String(error)}`);
            return null;
        }
    }

    /**
     * Evaluate the status callback received. This will be used in the LLM to determine the next steps.
     * If there is nothing to be done, just null the response.
     * 
     * @param statusCallback - The status callback object from Twilio
     * @returns The evaluated status callback object or null
     */
    async evaluateStatusCallback(statusCallback: StatusCallback): Promise<StatusCallback | null> {
        try {
            logOut('TwilioService', `Evaluating status callback: ${JSON.stringify(statusCallback)}`);
            // Do something and then emit the event type
            const callSid = statusCallback.CallSid;
            logOut('TwilioService', `Returning evaluated status callback for callSid: ${callSid}`);
            return statusCallback;
        } catch (error) {
            logError('TwilioService', `Error evaluating status callback: ${error instanceof Error ? error.message : String(error)}`);
            return null;
        }
    }

    /**
     * Sends a verification code via SMS or voice call using Twilio Verify.
     * 
     * @param {string} to - The phone number to send verification to in E.164 format
     * @param {string} channel - The channel to use: 'sms' or 'call'
     * @returns {Promise<string|null>} The verification SID if successful, null if sending fails
     */
    async sendVerification(to: string, channel: string = 'sms'): Promise<string | null> {
        try {
            const serviceSid = process.env.TWILIO_VERIFY_SERVICE_SID;
            if (!serviceSid) {
                throw new Error('TWILIO_VERIFY_SERVICE_SID environment variable not set');
            }

            logOut('TwilioService', `Sending verification via ${channel} to: ${to}`);

            const verification = await this.twilioClient.verify.v2.services(serviceSid)
                .verifications
                .create({
                    to: to,
                    channel: channel as 'sms' | 'call'
                });

            logOut('TwilioService', `Verification sent with SID: ${verification.sid}`);
            return verification.sid;

        } catch (error) {
            logError('TwilioService', `Error sending verification: ${error instanceof Error ? error.message : String(error)}`);
            return null;
        }
    }

    /**
     * Checks a verification code using Twilio Verify.
     * 
     * @param {string} to - The phone number the verification was sent to in E.164 format
     * @param {string} code - The verification code to check
     * @returns {Promise<boolean>} True if verification is successful, false otherwise
     */
    async checkVerification(to: string, code: string): Promise<boolean> {
        try {
            const serviceSid = process.env.TWILIO_VERIFY_SERVICE_SID;
            if (!serviceSid) {
                throw new Error('TWILIO_VERIFY_SERVICE_SID environment variable not set');
            }

            logOut('TwilioService', `Checking verification code for: ${to}`);

            const verificationCheck = await this.twilioClient.verify.v2.services(serviceSid)
                .verificationChecks
                .create({
                    to: to,
                    code: code
                });

            const isValid = verificationCheck.status === 'approved';
            logOut('TwilioService', `Verification check result: ${isValid ? 'approved' : 'denied'}`);
            return isValid;

        } catch (error) {
            logError('TwilioService', `Error checking verification: ${error instanceof Error ? error.message : String(error)}`);
            return false;
        }
    }

    /**
     * Processes Voice Intelligence webhook data.
     * 
     * @param {any} webhookData - The Voice Intelligence webhook payload
     * @returns {Promise<any>} Processed webhook data or null if processing fails
     */
    async processVoiceIntelligenceWebhook(webhookData: any): Promise<any> {
        try {
            logOut('TwilioService', `Processing Voice Intelligence webhook: ${JSON.stringify(webhookData)}`);
            
            // Extract relevant data from the webhook
            const processedData = {
                callSid: webhookData.CallSid,
                transcript: webhookData.Transcript,
                sentimentScore: webhookData.SentimentScore,
                operatorResults: webhookData.OperatorResults,
                timestamp: webhookData.Timestamp,
                processed: true
            };

            logOut('TwilioService', `Voice Intelligence data processed for call: ${processedData.callSid}`);
            return processedData;

        } catch (error) {
            logError('TwilioService', `Error processing Voice Intelligence webhook: ${error instanceof Error ? error.message : String(error)}`);
            return null;
        }
    }

    /**
     * Processes Call Recording webhook data.
     * 
     * @param {any} webhookData - The Call Recording webhook payload
     * @returns {Promise<any>} Processed webhook data or null if processing fails
     */
    async processCallRecordingWebhook(webhookData: any): Promise<any> {
        try {
            logOut('TwilioService', `Processing Call Recording webhook: ${JSON.stringify(webhookData)}`);
            
            // Extract relevant data from the webhook
            const processedData = {
                callSid: webhookData.CallSid,
                recordingSid: webhookData.RecordingSid,
                recordingUrl: webhookData.RecordingUrl,
                duration: webhookData.RecordingDuration,
                status: webhookData.RecordingStatus,
                timestamp: webhookData.Timestamp,
                processed: true
            };

            logOut('TwilioService', `Call Recording data processed for call: ${processedData.callSid}`);
            return processedData;

        } catch (error) {
            logError('TwilioService', `Error processing Call Recording webhook: ${error instanceof Error ? error.message : String(error)}`);
            return null;
        }
    }
}

export { TwilioService };
